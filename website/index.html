<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Metro HD</title>
  <link rel="shortcut icon" href="images/samuslogo.png"/>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="css/kultiad.css">
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
</head>
<body>
<nav id="TOC">
<div id="title">
<img src="images/samuslogo.png" />
<h1 class="title">Metro HD</h1>
</div>
<ul>
<li><a href="#about-us">About Us</a></li>
<li><a href="#the-task">The Task</a></li>
<li><a href="#the-game">The Game</a></li>
<li><a href="#drawing">Drawing</a></li>
<li><a href="#level-setup">Level Setup</a></li>
<li><a href="#movement">Movement</a></li>
<li><a href="#sound">Sound</a></li>
<li><a href="#download">Download</a></li>
</ul>
</nav>
<div id="body">
<h1 id="about-us">About Us</h1>
<figure>
<img src="images/wir.jpg" style="width:100.0%" />
</figure>
<ul>
<li>Daniela Kilian
<ul>
<li>BSc Applied Computer Science</li>
<li>6th semester</li>
</ul></li>
<li>Stefan Müller
<ul>
<li>BSc Applied Computer Science</li>
<li>6th semester</li>
</ul></li>
<li>Robert Schütz
<ul>
<li>BSc Mathematics</li>
<li>6th semester</li>
</ul></li>
</ul>
<p>We were supervised by Simon Kohlhepp.</p>
<h1 id="the-task">The Task</h1>
<p>Our task was to design and implement a game for a console resembling the Nintendo Gameboy. The console should also have a sound output for music and sound effects.</p>
<h2 id="hardware">Hardware</h2>
<figure>
<img src="images/console.jpg" alt="The hardware" style="width:50.0%" /><figcaption>The hardware</figcaption>
</figure>
<p>The console features two microcontrollers:</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/ATmega328">Atmega328</a> with
<ul>
<li>32 kB flash</li>
<li>2 kB SRAM</li>
<li>1 kB EEPROM</li>
</ul></li>
<li>Atmega168 with
<ul>
<li>16 kB flash</li>
<li>1 kB SRAM</li>
<li>512 B EEPROM</li>
</ul></li>
</ul>
<p>where the former is responsible for the game logic and controlling the display and the latter is used solely as a sound controller.</p>
<p>Furthermore, it features an <a href="http://www.lcd-module.com/eng/pdf/grafik/dogxl160-7e.pdf">EA DOGXL160L-7</a>. This LC display has a resolution of 160×104 pixels, but four vertically adjacent pixels are grouped together in so-called pages and can only be written as a whole. Therefore, when writing to the display, the x coordinate must be below 160 and the y coordinate below 25.</p>
<p>Last but not least, the 8 buttons known from the Gameboy are available:</p>
<ul>
<li>left, right, up, down</li>
<li>A, B</li>
<li>pause, select</li>
</ul>
<h1 id="the-game">The Game</h1>
<figure>
<img src="images/splash.png" style="width:100.0%" />
</figure>
<p>We based our game on the Metroid Series, especially on Metroid Fusion which is an action-adventure jump'n'run game.</p>
<p>So what is there to do in our game?</p>
<figure>
<img src="images/world2.png" alt="Fight against various Monster." style="width:50.0%" /><figcaption>Fight against various Monster.</figcaption>
</figure>
<p>There are no less than 8 monster types in our game. The protagonist faces at least one of them in each room and can kill them with his rockets or one of his bombs.</p>
<figure>
<img src="images/world3.png" alt="Explore different Level layouts." style="width:50.0%" /><figcaption>Explore different Level layouts.</figcaption>
</figure>
<p>Additionally there are different obstacles like water or spikes in the different levels.</p>
<figure>
<img src="images/world4.png" alt="Rest in the Recharge Room." style="width:50.0%" /><figcaption>Rest in the Recharge Room.</figcaption>
</figure>
<p>Before every fifth level, there is a so called recharge room, where the protagonist can refill his energy and ammunition.</p>
<figure>
<img src="images/world6.png" alt="Fight bosses." style="width:50.0%" /><figcaption>Fight bosses.</figcaption>
</figure>
<p>After the recharge room there will be a boss encounter in which one of the four bosses appear. All the bosses have different moves and abilities, so none is like the other.</p>
<figure>
<img src="images/world5.png" alt="Achieve Power-Ups." style="width:50.0%" /><figcaption>Achieve Power-Ups.</figcaption>
</figure>
<p>After successfully defeating a boss the protagonist obstains a Power-Up.</p>
<p>The amount of monsters which can appear in one room will increase by one after each successful boss fight.</p>
<h1 id="drawing">Drawing</h1>
<p>The display of the game console can recognise four grey scales. Each pixel on the display is defined by two bits (00 <span class="math inline">\(\widehat{=}\)</span> white pixel, 01 <span class="math inline">\(\widehat{=}\)</span> light grey pixel, 10 <span class="math inline">\(\widehat{=}\)</span> dark grey pixel, 11 <span class="math inline">\(\widehat{=}\)</span> black pixel).</p>
<p>To convert png images into code we wrote a python script, that takes a png image as input and converts it into an C array. The entries of the array are 8 bit entries, that represent the different pages (page <span class="math inline">\(\widehat{=}\)</span> four vertical pixels) of the image.</p>
<h2 id="drawing-a-sprite">Drawing a sprite</h2>
<p>Instead of using the <code>page()</code> function we wrote the following function, in which we used the display functionalities.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> drawsprite(<span class="dt">uint8_t</span> x, <span class="dt">uint8_t</span> y, <span class="dt">uint8_t</span> width, <span class="dt">uint8_t</span> height, <span class="dt">const</span> <span class="dt">uint8_t</span>* sprite)
{
    enable_window(x, y, width, height);
    <span class="cf">for</span> (<span class="dt">uint16_t</span> i = <span class="dv">0</span>; i &lt; width * height; ++i)
        sendbyte(pgm_read_byte_near(sprite + i), <span class="dv">1</span>);
    disable_window();
}</code></pre></div>
<p>This is faster than using the page() function, because fewer commands are send to the display.<br />
In order to draw pixel-by-pixel and not only pages we wrote the drawsprite_px function:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">void</span> drawsprite_px(<span class="dt">uint8_t</span> x, <span class="dt">uint8_t</span> y, <span class="dt">uint8_t</span> width, <span class="dt">uint8_t</span> height, <span class="dt">const</span> <span class="dt">uint8_t</span>* sprite)
{
    <span class="dt">uint8_t</span> offset = <span class="dv">2</span> * (y % <span class="dv">4</span>);
    <span class="cf">if</span> (offset == <span class="dv">0</span>)
    {
        drawsprite(x, y / <span class="dv">4</span>, width, height / <span class="dv">4</span>, sprite);
    }
    <span class="cf">else</span>
    {
        enable_window(x, y / <span class="dv">4</span>, width, height / <span class="dv">4</span> + <span class="dv">1</span>);
        <span class="dt">uint16_t</span> i = <span class="dv">0</span>;
        <span class="cf">for</span> (; i &lt; width; ++i)
            sendbyte(pgm_read_byte_near(sprite + i) &lt;&lt; offset, <span class="dv">1</span>);
        <span class="cf">for</span> (; i &lt; height / <span class="dv">4</span> * width; ++i)
            sendbyte(pgm_read_byte_near(sprite + i) &lt;&lt; offset | pgm_read_byte_near(sprite + i - width) &gt;&gt; (<span class="dv">8</span> - offset), <span class="dv">1</span>);
        <span class="cf">for</span> (; i &lt; (height / <span class="dv">4</span> + <span class="dv">1</span>) * width; ++i)
            sendbyte(pgm_read_byte_near(sprite + i - width) &gt;&gt; (<span class="dv">8</span> - offset), <span class="dv">1</span>);
        disable_window();
    }
}</code></pre></div>
<!-- TODO drawsprite() & drawsprite_px() -->
<h1 id="level-setup">Level Setup</h1>
<p>Every level consists of a number of rooms, whereby the number of rooms is a random number between one and five. Furthermore the monster(s), the positions of the platforms and water are chosen randomly for every new room and the floor and ceiling sprite is chosen randomly for every new level.</p>
<p>To make sure that a level you have already been to looks the same as before, we choose the seed of the random number generator depending on the level and on the room the protagonist is in. There are three variables for the three different heights on which the platforms can appear and one variable for the water:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">    srandom(level_seed + level_pos);
    platforms_13 = random();
    platforms_19 = random();
    platforms_24 = random();
    nofloor = random();</code></pre></div>
<h2 id="depth-first-search">Depth-first Search</h2>
<p>Since the position of the platforms and the water is chosen randomly, it is possible that the protagonist is not able to simply walk from left to right, Nevertheless, we have to ensure that he can reach the door. Therefore, we implemented an algorithm based on <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first search</a> that tries to find a path from left to right and also considers jumping on platforms. Below, we will explain the idea behind this algorithm using an exemplary level.</p>
<figure>
<img src="images/dfs1.png" alt="We start at the bottom left corner, from where we can only walk to the right." style="width:50.0%" /><figcaption>We start at the bottom left corner, from where we can only walk to the right.</figcaption>
</figure>
<figure>
<img src="images/dfs2.png" alt="From there, we can either jump onto the platform at the left or over the water," style="width:50.0%" /><figcaption>From there, we can either jump onto the platform at the left or over the water,</figcaption>
</figure>
<figure>
<img src="images/dfs3.png" alt="We first consider the latter alternative. The only option is to continue walking." style="width:50.0%" /><figcaption>We first consider the latter alternative. The only option is to continue walking.</figcaption>
</figure>
<figure>
<img src="images/dfs4.png" alt="But now, we discover that there is no further path that we can take since the platform is too far away." style="width:50.0%" /><figcaption>But now, we discover that there is no further path that we can take since the platform is too far away.</figcaption>
</figure>
<figure>
<img src="images/dfs5.png" alt="Therefore, we consider the other alternative. We see that we can jump ono another platform." style="width:50.0%" /><figcaption>Therefore, we consider the other alternative. We see that we can jump ono another platform.</figcaption>
</figure>
<figure>
<img src="images/dfs6.png" alt="Now, we jump over the gap between two platforms." style="width:50.0%" /><figcaption>Now, we jump over the gap between two platforms.</figcaption>
</figure>
<figure>
<img src="images/dfs7.png" alt="This goes on until we have found a path to the door." style="width:50.0%" /><figcaption>This goes on until we have found a path to the door.</figcaption>
</figure>
<p>If there is no path, we set the <code>nofloor</code> variable to a new random value and try again to find a path to the door.</p>
<h1 id="movement">Movement</h1>
<p>To make things simpler, we decided to move only whole pages in the vertical direction. Additionally, different monsters etc. are never at the same position, or if they are then this means that e.g. a projectile has hit a monster and both can be undrawn. This allows us to only consider the object in motion when redrawing it at a new position.</p>
<h2 id="implementation">Implementation</h2>
<p>We use a single C <code>struct</code> for monsters, projectiles and the protagonist. This enables us to reuse the functions responsible for movement for all of them, which saves us quite some flash space.</p>
<div class="sourceCode" include="../master/character.h" startline="11" endline="30"><pre class="sourceCode c"><code class="sourceCode c"><span class="kw">struct</span> Character
{
    <span class="dt">uint8_t</span> x;
    <span class="dt">uint8_t</span> y;
    <span class="kw">enum</span> {LOOK_MONSTER_GEEGA, LOOK_MONSTER_MEMU, LOOK_MONSTER_METROID, LOOK_MONSTER_LITTLE, LOOK_EYEMONSTER, LOOK_MONSTER_ZOOMER, LOOK_MONSTER_HORNOAD, LOOK_MONSTER_SIDEHOPPER, LOOK_BOSS_SECROB, LOOK_BOSS_ZAZABI, LOOK_NEO_RIDLEY_DRAGON, LOOK_BOSS_MEGACOREX, LOOK_BIGXPARASITE, LOOK_PROTAGONIST,  LOOK_ROCKET, LOOK_BOMB, LOOK_ENERGYTANK, LOOK_XPARASITE1, LOOK_XPARASITE2, LOOK_FIREBALL, LOOK_ARROW, LOOK_ARROW_UP, LOOK_HIDDEN} look;
    <span class="dt">uint8_t</span> lookstate; <span class="co">// to e.g. store whether the wings are turned upwards or downwards</span>
    <span class="dt">uint32_t</span> lastlookstatechg;
    <span class="dt">uint8_t</span> width;  <span class="co">// in pixels</span>
    <span class="dt">uint8_t</span> height; <span class="co">// in pixels</span>
    <span class="kw">enum</span> {DIRECTION_LEFT, DIRECTION_RIGHT} direction;
    <span class="kw">enum</span> {DIRECTION_UP, DIRECTION_DOWN} verticaldirection;
    <span class="dt">int8_t</span> jumpstate;
    <span class="dt">uint8_t</span> initial_health;
    <span class="dt">int8_t</span> health;
    <span class="dt">uint8_t</span> damage;
    <span class="dt">uint8_t</span> jumpheight;
    <span class="kw">enum</span> {FOLLOW_PROTAGONIST, BACK_AND_FORTH, PROJECTILE, HIDDEN, JUMP, JUMPMOVE, FLYING_AROUND, BOMB, ENERGYTANK, XPARASITE, FIREBALL, SECROB, BOSS_DRAGON_GROUND, ARROW, ARROW_UP, BOSS_DRAGON_ATTACK, BOSS_DRAGON_AIR, ZAZABI} movement;
    <span class="dt">uint8_t</span> x_pace;
    <span class="dt">uint8_t</span> y_pace;
};</code></pre></div>
<p>First, there are the functions <code>moveleft</code>, <code>moveright</code>, <code>moveup</code> and <code>movedown</code>. These take care of</p>
<ul>
<li>checking if there is an obstacle, e.g. a platform, in the respective direction,</li>
<li>redrawing the character at its new position and</li>
<li>clearing the pixels that are left over from the old position.</li>
</ul>
<p>Then, there is also a function <code>move</code> which automatically decides in which direction to move. For example, a monster with <code>movement==FOLLOW_PROTAGONIST</code> will automatically move towards the protagonist whenever this function is called with that very monster as argument.</p>
<h1 id="sound">Sound</h1>
<p>We have different background tunes playing during the levels. Additionally, there is a characteristic music for each boss you can encounter. The code supports playing up to three tones at the same time. Additionally, sound effects are played ontop the background music when a rocket is shot and when a bomb explodes.</p>
<p>Since synthesizing sound is a time-expensive task, this is done on a dedicated microcontroller (Atmega168) to which the speaker is connected through pin B1.</p>
<p>To generate a sound wave, one can use <a href="https://en.wikipedia.org/wiki/Pulse-width_modulation">pulse-width modulation</a>. If the frequency of the PWM signal is too high for for the human ear to perceive, then the displacement of a sound wave can be determined by the pulse width:</p>
<figure>
<img src="images/pwm.png" alt="A PWM signal generating a sine wave" /><figcaption>A PWM signal generating a sine wave</figcaption>
</figure>
<p>But instead of a sinusodial wave, we use <a href="https://en.wikipedia.org/wiki/Sawtooth_wave">saw waves</a>. To generate this PWM signal, we use Timer1 of the Atmega168 in 8-bit Fast PWM mode. The <code>TOP</code> value of <span class="math inline">\(255\)</span> is reached with a frequency of <span class="math inline">\(62500\,\mathrm{Hz}\)</span>. By setting the register <code>OCR1A</code>, we can determine the pulse width, because B1 is set to high at <span class="math inline">\(0\)</span> and set to low when reaching <code>OCR1A</code>.</p>
<p><code>OCR1A</code> is set in the interrupt of Timer2, which is called with a frequency of <span class="math inline">\(15625\,\mathrm{Hz}\)</span>. To e.g. generate a tone with <span class="math inline">\(440\,\mathrm{Hz}\)</span>, we simply need to reach the maximum pulse width (<span class="math inline">\(255\)</span>) with a frequency of <span class="math inline">\(440\,\mathrm{Hz}\)</span>. To do this, the pulse width can simply be incremented by</p>
<p><span class="math display">\[ \frac{255}{15625\,\mathrm{Hz} / 440\,\mathrm{Hz}} \approx 7.18 \]</span></p>
<p>each time the interrupt is called. Because of integer overflow, it will automatically be set to <span class="math inline">\(0\)</span> again after reaching <span class="math inline">\(255\)</span> if we use a <code class="sourceCode c"><span class="dt">uint8_t</span></code>. But since we cannot represent non-integer values like <span class="math inline">\(7.18\)</span>, we use <code class="sourceCode c"><span class="dt">uint16_t</span></code>s and increment the pulse width by</p>
<p><span class="math display">\[ \lfloor 7.18 \cdot 256 \rfloor = \lfloor 1838.08 \rfloor = 1838 \]</span></p>
<p>which is obviously a lot more accurate. Additionally, Timer2 is used to keep track of the time.</p>
<p>To make easier to write our own music for the console and use existing tunes, we wrote a Python script that converts MIDI files into C arrays that are stored in the <code>PROGMEM</code>. We use the <a href="https://mido.readthedocs.io/en/latest/">mido</a> library to read the files. The entries of these arrays contain information about</p>
<ul>
<li>the track (as explained above, there are three channels for the music),</li>
<li>the increment corresponding to the tone that should be played (an increment of <span class="math inline">\(0\)</span> means that no tone should be playing on this track) and</li>
<li>the delay until the next entry in the array should be read.</li>
</ul>
<p>For example, an array could look like this:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="dt">const</span> Event boss4[] PROGMEM = {
    { { .track = <span class="dv">0</span>, .increment = <span class="dv">615</span>, .delay = <span class="dv">0</span> } },
    { { .track = <span class="dv">1</span>, .increment = <span class="dv">307</span>, .delay = <span class="dv">0</span> } },
    { { .track = <span class="dv">2</span>, .increment = <span class="dv">2463</span>, .delay = <span class="dv">2812</span> } },
    { { .track = <span class="dv">2</span>, .increment = <span class="dv">1231</span>, .delay = <span class="dv">2812</span> } },
    { { .track = <span class="dv">0</span>, .increment = <span class="dv">1231</span>, .delay = <span class="dv">0</span> } },
    ...,
    STOP
};</code></pre></div>
<p>Here, you can hear some of the music as it is played by the console: <audio src="static/ingame1.ogg" controls></audio> <audio src="static/ingame2.ogg" controls></audio> <audio src="static/gameover.ogg" controls></audio></p>
<h1 id="download">Download</h1>
<p>You can download the source code of this project from <a href="static/code.zip">here</a>. It is also available on <a href="https://github.com/dotlambda/metro-hd">GitHub</a>. Also have a look at the <a href="static/slides.pdf">slides</a> of the presentation we gave at the end of the practical.</p>
<h2 id="statistics">Statistics</h2>
<p>Our git repository has about 450 commits.</p>
<p>Regarding the lines of code, excluding those generated by scripts, we have the <code>master</code> folder:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">find</span> master/ -type f -not -name <span class="st">&quot;sprites.*&quot;</span> <span class="kw">|</span> <span class="fu">xargs</span> sloccount
<span class="ex">ansic</span>:         3279 (98.44%)
<span class="ex">python</span>:          52 (1.56%)</code></pre></div>
<p>and the <code>slave</code> folder:</p>
<div class="sourceCode"><pre class="sourceCode sh"><code class="sourceCode bash">$ <span class="fu">find</span> slave/ -type f -not -name <span class="st">&quot;music.*&quot;</span> -not -name <span class="st">&quot;fx.*&quot;</span> <span class="kw">|</span> <span class="fu">xargs</span> sloccount
<span class="ex">ansic</span>:          327 (75.00%)
<span class="ex">python</span>:         109 (25.00%)</code></pre></div>
</div>
</body>
</html>
